////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
// USE COPY & PASTE TO MAKE USE OF THE FUNCTION IMPLEMENTATIONS!!
////////////////////////////////////////////////////////////////
// Generated by kl2exe version 1.11.2
////////////////////////////////////////////////////////////////

#include "AlembicPropertyHeader_functions.h"


#include "extension.h"
  

using namespace Fabric::EDK;


// Defined at PropertyHeader.kl:14:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_construct(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_construct")

  construct_AbcBasePtr(AbcG::PropertyHeader)
  
  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_construct")
}

// Defined at PropertyHeader.kl:15:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_free(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_free")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    return;
  }
  free_AbcBasePtr(AbcG::PropertyHeader)
  
  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_free")
}

// Defined at PropertyHeader.kl:17:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_construct2Args(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::INParam name,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicMetaData >::INParam metaData
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_construct2Args")

  std::string abcName = "";
  if(!conv_from_String(name, abcName)){
    setError("Error in AlembicPropertyHeader_construct2Args. unable to convert: name");
    return;
  }
  Abc::MetaData * abcMetaData = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>(metaData, abcMetaData)){
    setError("Error in AlembicPropertyHeader_construct2Args. unable to convert: metaData");
    return;
  }

  this_->handle = new PtrHandle<Abc::PropertyHeader>(new Abc::PropertyHeader(abcName, *abcMetaData), true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_construct2Args")
}

// Defined at PropertyHeader.kl:18:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_construct5Args(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::INParam name,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam propType,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicMetaData >::INParam metaData,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam dataType,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSampling >::INParam timeSampling
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_construct5Args")

  std::string abcName = "";
  if(!conv_from_String(name, abcName)){
    setError("Error in AlembicPropertyHeader_construct5Args. unable to convert: name");
    return;
  }
  unsigned int abcPropType = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(propType, abcPropType)){
    setError("Error in AlembicPropertyHeader_construct5Args. unable to convert: propType");
    return;
  }
  Abc::MetaData * abcMetaData = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>(metaData, abcMetaData)){
    setError("Error in AlembicPropertyHeader_construct5Args. unable to convert: metaData");
    return;
  }
  Abc::DataType abcDataType;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(dataType, abcDataType)){
    setError("Error in AlembicPropertyHeader_construct5Args. unable to convert: dataType");
    return;
  }
  Abc::TimeSamplingPtr abcTimeSampling;
  if(!conv_from_AbcBase<KL::AlembicTimeSampling, Abc::TimeSamplingPtr>(timeSampling, abcTimeSampling)){
    setError("Error in AlembicPropertyHeader_construct5Args. unable to convert: timeSampling");
    return;
  }

  this_->handle = new PtrHandle<Abc::PropertyHeader>(new Abc::PropertyHeader(
    abcName, 
    (Abc::PropertyType)abcPropType,
    *abcMetaData,
    abcDataType,
    abcTimeSampling
  ), true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_construct5Args")
}

// Defined at PropertyHeader.kl:20:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_getName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_getName")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_getName. unable to convert: this_");
    return;
  }
  std::string abc_result = abcThis_->getName();
  conv_to_String(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_getName")
}

// Defined at PropertyHeader.kl:21:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_setName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::INParam name
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_setName")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_setName. unable to convert: this_");
    return;
  }
  std::string abcName = "";
  if(!conv_from_String(name, abcName)){
    setError("Error in AlembicPropertyHeader_setName. unable to convert: name");
    return;
  }
  abcThis_->setName(abcName);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_setName")
}

// Defined at PropertyHeader.kl:22:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicPropertyHeader_getPropertyType(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_getPropertyType")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_getPropertyType. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_->getPropertyType();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicPropertyHeader_getPropertyType", 0)
}

// Defined at PropertyHeader.kl:23:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_setPropertyType(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam propType
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_setPropertyType")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_setPropertyType. unable to convert: this_");
    return;
  }
  unsigned int abcPropType = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(propType, abcPropType)){
    setError("Error in AlembicPropertyHeader_setPropertyType. unable to convert: propType");
    return;
  }
  abcThis_->setPropertyType((Abc::PropertyType)abcPropType);
  
  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_setPropertyType")
}

// Defined at PropertyHeader.kl:24:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicPropertyHeader_isScalar(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_isScalar")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_isScalar. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_->isScalar();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicPropertyHeader_isScalar", false)
}

// Defined at PropertyHeader.kl:25:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicPropertyHeader_isArray(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_isArray")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_isArray. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_->isArray();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicPropertyHeader_isArray", false)
}

// Defined at PropertyHeader.kl:26:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicPropertyHeader_isCompound(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_isCompound")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_isCompound. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_->isCompound();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicPropertyHeader_isCompound", false)
}

// Defined at PropertyHeader.kl:27:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicPropertyHeader_isSimple(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_isSimple")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_isSimple. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_->isSimple();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicPropertyHeader_isSimple", false)
}

// Defined at PropertyHeader.kl:28:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_getMetaData(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicMetaData >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_getMetaData")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_getMetaData. unable to convert: this_");
    return;
  }
  
  Abc::MetaData * abc_result = new Abc::MetaData(abcThis_->getMetaData());
  conv_to_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>(abc_result, _result, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_getMetaData")
}

// Defined at PropertyHeader.kl:29:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_setMetaData(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicMetaData >::INParam metaData
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_setMetaData")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_setMetaData. unable to convert: this_");
    return;
  }
  Abc::MetaData * abcMetaData = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>(metaData, abcMetaData)){
    setError("Error in AlembicPropertyHeader_setMetaData. unable to convert: metaData");
    return;
  }
  abcThis_->setMetaData(*abcMetaData);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_setMetaData")
}

// Defined at PropertyHeader.kl:30:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_getDataType(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_getDataType")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_getDataType. unable to convert: this_");
    return;
  }
  Abc::DataType abc_result = abcThis_->getDataType();
  conv_to_AbcBase<KL::AlembicDataType, Abc::DataType>(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_getDataType")
}

// Defined at PropertyHeader.kl:31:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_setDataType(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam dataType
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_setDataType")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_setDataType. unable to convert: this_");
    return;
  }
  Abc::DataType abcDataType;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(dataType, abcDataType)){
    setError("Error in AlembicPropertyHeader_setDataType. unable to convert: dataType");
    return;
  }
  abcThis_->setDataType(abcDataType);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_setDataType")
}

// Defined at PropertyHeader.kl:32:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_getTimeSampling(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSampling >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_getTimeSampling")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_getTimeSampling. unable to convert: this_");
    return;
  }
  Abc::TimeSamplingPtr abc_result = abcThis_->getTimeSampling();
  conv_to_AbcBase<KL::AlembicTimeSampling, Abc::TimeSamplingPtr>(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_getTimeSampling")
}

// Defined at PropertyHeader.kl:33:1
FABRIC_EXT_EXPORT void AlembicPropertyHeader_setTimeSampling(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicPropertyHeader >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSampling >::INParam timeSampling
)
{
  ALEMBIC_TRY_STATEMENT("AlembicPropertyHeader_setTimeSampling")

  Abc::PropertyHeader * abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(this_, abcThis_)){
    setError("Error in AlembicPropertyHeader_setTimeSampling. unable to convert: this_");
    return;
  }
  Abc::TimeSamplingPtr abcTimeSampling;
  if(!conv_from_AbcBase<KL::AlembicTimeSampling, Abc::TimeSamplingPtr>(timeSampling, abcTimeSampling)){
    setError("Error in AlembicPropertyHeader_setTimeSampling. unable to convert: timeSampling");
    return;
  }
  abcThis_->setTimeSampling(abcTimeSampling);

  ALEMBIC_CATCH_STATEMENT("AlembicPropertyHeader_setTimeSampling")
}
