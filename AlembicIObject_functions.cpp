////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
// USE COPY & PASTE TO MAKE USE OF THE FUNCTION IMPLEMENTATIONS!!
////////////////////////////////////////////////////////////////
// Generated by kl2exe version 1.11.2
////////////////////////////////////////////////////////////////

#include "AlembicIObject_functions.h"


#include "extension.h"
  

using namespace Fabric::EDK;


// Defined at IObject.kl:9:1
FABRIC_EXT_EXPORT void AlembicIObject_construct(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_construct")

  this_->handle = NULL;
  
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_construct")
}

// Defined at IObject.kl:10:1
FABRIC_EXT_EXPORT void AlembicIObject_free(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_free")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    return;
  }
  free_AbcBasePtr(Abc::IObject)
  
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_free")
}

// Defined at IObject.kl:11:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicIObject_valid(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_valid")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    return false;
  }
  bool abc_result = abcThis_->valid();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIObject_valid", false)
}

// Defined at IObject.kl:14:1
FABRIC_EXT_EXPORT void AlembicIObject_getName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getName")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getName. unable to convert: this_");
    return;
  }
  std::string abc_result = abcThis_->getName();
  conv_to_String(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getName")
}

// Defined at IObject.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_getFullName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getFullName")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getFullName. unable to convert: this_");
    return;
  }
  std::string abc_result = abcThis_->getFullName();
  conv_to_String(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getFullName")
}

// Defined at IObject.kl:16:1
FABRIC_EXT_EXPORT void AlembicIObject_getMetaData(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicMetaData >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getMetaData")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getMetaData. unable to convert: this_");
    return;
  }
  AlembicGetMetaData()
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getMetaData")
}

// Defined at IObject.kl:17:1
FABRIC_EXT_EXPORT void AlembicIObject_getArchive(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getArchive")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getArchive. unable to convert: this_");
    return;
  }
  Abc::IArchive* abc_result = new Abc::IArchive(abcThis_->getArchive());
  conv_to_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(abc_result, _result, true);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getArchive")
}

// Defined at IObject.kl:18:1
FABRIC_EXT_EXPORT void AlembicIObject_getParent(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getParent")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getParent. unable to convert: this_");
    return;
  }
  Abc::IObject* abc_result = new Abc::IObject(abcThis_->getParent());
  conv_to_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(abc_result, _result, true);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getParent")
}

// Defined at IObject.kl:19:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicIObject_getNumChildren(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getNumChildren")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getNumChildren. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_->getNumChildren();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIObject_getNumChildren", 0)
}

// Defined at IObject.kl:20:1
FABRIC_EXT_EXPORT void AlembicIObject_getProperties(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicICompoundProperty >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getProperties")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getProperties. unable to convert: this_");
    return;
  }
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getProperties")
}

// Defined at IObject.kl:21:1
FABRIC_EXT_EXPORT void AlembicIObject_getChild(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam childIndex
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getChild")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getChild. unable to convert: this_");
    return;
  }
  unsigned int abcChildIndex = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(childIndex, abcChildIndex)){
    setError("Error in AlembicIObject_getChild. unable to convert: childIndex");
    return;
  }
  Abc::IObject* abc_result = new Abc::IObject(abcThis_->getChild(abcChildIndex));
  conv_to_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(abc_result, _result, true);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getChild")
}

// Defined at IObject.kl:22:1
FABRIC_EXT_EXPORT void AlembicIObject_getChild_byName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::INParam childName
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_getChild_byName")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_getChild_byName. unable to convert: this_");
    return;
  }
  std::string abcChildName = "";
  if(!conv_from_String(childName, abcChildName)){
    setError("Error in AlembicIObject_getChild_byName. unable to convert: childName");
    return;
  }
  Abc::IObject* abc_result = new Abc::IObject(abcThis_->getChild(abcChildName));
  conv_to_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(abc_result, _result, true);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_getChild_byName")
}

// Defined at IObject.kl:23:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicIObject_isInstanceRoot(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_isInstanceRoot")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_isInstanceRoot. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_->isInstanceRoot();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIObject_isInstanceRoot", false)
}

// Defined at IObject.kl:24:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicIObject_isInstanceDescendant(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_isInstanceDescendant")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_isInstanceDescendant. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_->isInstanceDescendant();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIObject_isInstanceDescendant", false)
}

// Defined at IObject.kl:25:1
FABRIC_EXT_EXPORT void AlembicIObject_instanceSourcePath(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_instanceSourcePath")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_instanceSourcePath. unable to convert: this_");
    return;
  }
  std::string abc_result = abcThis_->instanceSourcePath();
  conv_to_String(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicIObject_instanceSourcePath")
}

// Defined at IObject.kl:26:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicIObject_isChildInstance(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam childIndex
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_isChildInstance")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_isChildInstance. unable to convert: this_");
    return false;
  }
  unsigned int abcChildIndex = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(childIndex, abcChildIndex)){
    setError("Error in AlembicIObject_isChildInstance. unable to convert: childIndex");
    return false;
  }
  bool abc_result = abcThis_->isChildInstance(abcChildIndex);
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIObject_isChildInstance", false)
}

// Defined at IObject.kl:27:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicIObject_isChildInstance_byName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::INParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::INParam childName
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_isChildInstance_byName")

  Abc::IObject* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(this_, abcThis_)){
    setError("Error in AlembicIObject_isChildInstance_byName. unable to convert: this_");
    return false;
  }
  std::string abcChildName = "";
  if(!conv_from_String(childName, abcChildName)){
    setError("Error in AlembicIObject_isChildInstance_byName. unable to convert: childName");
    return false;
  }
  bool abc_result = abcThis_->isChildInstance(abcChildName);
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIObject_isChildInstance_byName", false)
}

// Defined at IXform.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromIXform(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIXform >::INParam xform
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromIXform")

  AbcG::IXform* abcXform = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIXform, AbcG::IXform>(xform, abcXform)){
    setError("Error in AlembicIObject_constructFromIXform. unable to convert: xform");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcXform, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromIXform")
}

// Defined at ICamera.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromICamera(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicICamera >::INParam camera
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromICamera")

  AbcG::ICamera* abcCamera = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicICamera, AbcG::ICamera>(camera, abcCamera)){
    setError("Error in AlembicIObject_constructFromICamera. unable to convert: camera");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcCamera, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromICamera")
}

// Defined at ILight.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromILight(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicILight >::INParam light
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromILight")

  AbcG::ILight* abcLight = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicILight, AbcG::ILight>(light, abcLight)){
    setError("Error in AlembicIObject_constructFromILight. unable to convert: light");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcLight, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromILight")
}

// Defined at IPoints.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromIPoints(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIPoints >::INParam points
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromIPoints")

  AbcG::IPoints* abcPoints = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIPoints, AbcG::IPoints>(points, abcPoints)){
    setError("Error in AlembicIObject_constructFromIPoints. unable to convert: points");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcPoints, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromIPoints")
}

// Defined at IPolyMesh.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromIPolyMesh(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIPolyMesh >::INParam polyMesh
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromIPolyMesh")

  AbcG::IPolyMesh* abcPolyMesh = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIPolyMesh, AbcG::IPolyMesh>(polyMesh, abcPolyMesh)){
    setError("Error in AlembicIObject_constructFromIPolyMesh. unable to convert: polyMesh");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcPolyMesh, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromIPolyMesh")
}

// Defined at ICurves.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromICurves(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicICurves >::INParam curves
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromICurves")

  AbcG::ICurves* abcCurves = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicICurves, AbcG::ICurves>(curves, abcCurves)){
    setError("Error in AlembicIObject_constructFromICurves. unable to convert: curves");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcCurves, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromICurves")
}

// Defined at INuPatch.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromINuPatch(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicINuPatch >::INParam patch
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromINuPatch")

  AbcG::INuPatch* abcPatch = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicINuPatch, AbcG::INuPatch>(patch, abcPatch)){
    setError("Error in AlembicIObject_constructFromINuPatch. unable to convert: patch");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcPatch, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromINuPatch")
}

// Defined at ISubD.kl:15:1
FABRIC_EXT_EXPORT void AlembicIObject_constructFromISubD(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicISubD >::INParam subd
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIObject_constructFromISubD")

  AbcG::ISubD* abcSubd = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicISubD, AbcG::ISubD>(subd, abcSubd)){
    setError("Error in AlembicIObject_constructFromISubD. unable to convert: subd");
    return;
  }

  Abc::IObject * abcThis_ = new Abc::IObject(*abcSubd, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIObject_constructFromISubD")
}
