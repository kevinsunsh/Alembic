////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
// USE COPY & PASTE TO MAKE USE OF THE FUNCTION IMPLEMENTATIONS!!
////////////////////////////////////////////////////////////////
// Generated by kl2exe version 1.11.2
////////////////////////////////////////////////////////////////

#include "AlembicIArchive_functions.h"


#include "extension.h"
  

using namespace Fabric::EDK;


// Defined at IArchive.kl:9:1
FABRIC_EXT_EXPORT void AlembicIArchive_construct(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_construct")

  this_->handle = NULL;
  
  ALEMBIC_CATCH_STATEMENT("AlembicIArchive_construct")
}

// Defined at IArchive.kl:10:1
FABRIC_EXT_EXPORT void AlembicIArchive_free(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_free")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    return;
  }
  free_AbcBasePtr(Abc::IArchive)
  
  ALEMBIC_CATCH_STATEMENT("AlembicIArchive_free")
}

// Defined at IArchive.kl:11:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicIArchive_valid(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_valid")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    return false;
  }
  bool abc_result = abcThis_->valid();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIArchive_valid", false)
}

// Defined at IArchive.kl:14:1
FABRIC_EXT_EXPORT void AlembicIArchive_constructFromString(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::INParam fileName
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_constructFromString")

  std::string abcFileName = "";
  if(!conv_from_String(fileName, abcFileName)){
    setError("Error in AlembicIArchive_constructFromString. unable to convert: fileName");
    return;
  }

  if(abcFileName.length() == 0)
  {
    setError("AlembicIArchive_constructFromString: No fileName specified.");
    return;
  }
  AbcF::IFactory factory;
  factory.setPolicy(Abc::ErrorHandler::kThrowPolicy);

  AbcF::IFactory::CoreType coreType;
  Abc::IArchive * abcArchive = new Abc::IArchive(factory.getArchive(fileName.data(), coreType));
  if ( coreType == AbcF::IFactory::kUnknown )
  {
    setError("AlembicIArchive_constructFromString: Unknown core type / file not found.");
    delete(abcArchive);
    return;
  }
  this_->handle = new PtrHandle<Abc::IArchive>(abcArchive, true);
    
  ALEMBIC_CATCH_STATEMENT("AlembicIArchive_constructFromString")
}

// Defined at IArchive.kl:16:1
FABRIC_EXT_EXPORT void AlembicIArchive_getName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_getName")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    setError("Error in AlembicIArchive_getName. unable to convert: this_");
    return;
  }
  std::string abc_result = abcThis_->getName();
  conv_to_String(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicIArchive_getName")
}

// Defined at IArchive.kl:17:1
FABRIC_EXT_EXPORT void AlembicIArchive_getTop(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIObject >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_getTop")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    setError("Error in AlembicIArchive_getTop. unable to convert: this_");
    return;
  }
  Abc::IObject* abc_result = new Abc::IObject(abcThis_->getTop());
  conv_to_AbcBasePtr<KL::AlembicIObject, Abc::IObject>(abc_result, _result, true);

  ALEMBIC_CATCH_STATEMENT("AlembicIArchive_getTop")
}

// Defined at IArchive.kl:18:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicIArchive_getNumTimeSamplings(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_getNumTimeSamplings")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    setError("Error in AlembicIArchive_getNumTimeSamplings. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_->getNumTimeSamplings();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIArchive_getNumTimeSamplings", 0)
}

// Defined at IArchive.kl:19:1
FABRIC_EXT_EXPORT void AlembicIArchive_getTimeSampling(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSampling >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam index
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_getTimeSampling")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    setError("Error in AlembicIArchive_getTimeSampling. unable to convert: this_");
    return;
  }
  unsigned int abcIndex = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(index, abcIndex)){
    setError("Error in AlembicIArchive_getTimeSampling. unable to convert: index");
    return;
  }
  Abc::TimeSamplingPtr abc_result = abcThis_->getTimeSampling(abcIndex);
  conv_to_AbcBase<KL::AlembicTimeSampling, Abc::TimeSamplingPtr>(abc_result, _result);

  ALEMBIC_CATCH_STATEMENT("AlembicIArchive_getTimeSampling")
}

// Defined at IArchive.kl:20:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicIArchive_getMaxNumSamplesForTimeSamplingIndex(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam iIndex
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_getMaxNumSamplesForTimeSamplingIndex")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    setError("Error in AlembicIArchive_getMaxNumSamplesForTimeSamplingIndex. unable to convert: this_");
    return 0;
  }
  unsigned int abcIIndex = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(iIndex, abcIIndex)){
    setError("Error in AlembicIArchive_getMaxNumSamplesForTimeSamplingIndex. unable to convert: iIndex");
    return 0;
  }
  unsigned int abc_result = abcThis_->getMaxNumSamplesForTimeSamplingIndex(abcIIndex);
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIArchive_getMaxNumSamplesForTimeSamplingIndex", 0)
}

// Defined at IArchive.kl:21:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicIArchive_getArchiveVersion(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicIArchive >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicIArchive_getArchiveVersion")

  Abc::IArchive* abcThis_ = NULL;
  if(!conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>(this_, abcThis_)){
    setError("Error in AlembicIArchive_getArchiveVersion. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_->getArchiveVersion();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicIArchive_getArchiveVersion", 0)
}
