////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
// USE COPY & PASTE TO MAKE USE OF THE FUNCTION IMPLEMENTATIONS!!
////////////////////////////////////////////////////////////////
// Generated by kl2exe version 1.11.2
////////////////////////////////////////////////////////////////

#include "AlembicTimeSamplingType_functions.h"


#include "extension.h"
  

using namespace Fabric::EDK;


// Defined at TimeSamplingType.kl:12:1
FABRIC_EXT_EXPORT void AlembicTimeSamplingType_construct(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_construct")

  construct_AbcBase(Abc::TimeSamplingType)
  
  ALEMBIC_CATCH_STATEMENT("AlembicTimeSamplingType_construct")
}

// Defined at TimeSamplingType.kl:13:1
FABRIC_EXT_EXPORT void AlembicTimeSamplingType_free(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_free")

  Abc::TimeSamplingType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>(this_, abcThis_)){
    return;
  }
  free_AbcBase(Abc::TimeSamplingType)
  
  ALEMBIC_CATCH_STATEMENT("AlembicTimeSamplingType_free")
}

// Defined at TimeSamplingType.kl:15:1
FABRIC_EXT_EXPORT void AlembicTimeSamplingType_constructFromFloat64(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::Float64 >::INParam timePerCycle
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_constructFromFloat64")

  double abcTimePerCycle = 0;
  if(!conv_from_baseType<KL::Float64, double>(timePerCycle, abcTimePerCycle)){
    setError("Error in AlembicTimeSamplingType_constructFromFloat64. unable to convert: timePerCycle");
    return;
  }

  this_->handle = new Handle<Abc::TimeSamplingType>(Abc::TimeSamplingType((Abc::chrono_t)timePerCycle));
    
  ALEMBIC_CATCH_STATEMENT("AlembicTimeSamplingType_constructFromFloat64")
}

// Defined at TimeSamplingType.kl:16:1
FABRIC_EXT_EXPORT void AlembicTimeSamplingType_constructFromUInt32Float64(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam numSamplesPerCycle,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::Float64 >::INParam timePerCycle
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_constructFromUInt32Float64")

  unsigned int abcNumSamplesPerCycle = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(numSamplesPerCycle, abcNumSamplesPerCycle)){
    setError("Error in AlembicTimeSamplingType_constructFromUInt32Float64. unable to convert: numSamplesPerCycle");
    return;
  }
  double abcTimePerCycle = 0;
  if(!conv_from_baseType<KL::Float64, double>(timePerCycle, abcTimePerCycle)){
    setError("Error in AlembicTimeSamplingType_constructFromUInt32Float64. unable to convert: timePerCycle");
    return;
  }

  this_->handle = new Handle<Abc::TimeSamplingType>(Abc::TimeSamplingType(numSamplesPerCycle, (Abc::chrono_t)timePerCycle));
    
  ALEMBIC_CATCH_STATEMENT("AlembicTimeSamplingType_constructFromUInt32Float64")
}

// Defined at TimeSamplingType.kl:17:1
FABRIC_EXT_EXPORT void AlembicTimeSamplingType_constructFromAcyclicFlag(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam flag
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_constructFromAcyclicFlag")

  unsigned int abcFlag = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(flag, abcFlag)){
    setError("Error in AlembicTimeSamplingType_constructFromAcyclicFlag. unable to convert: flag");
    return;
  }

  this_->handle = new Handle<Abc::TimeSamplingType>(Abc::TimeSamplingType((Abc::TimeSamplingType::AcyclicFlag)flag));
    
  ALEMBIC_CATCH_STATEMENT("AlembicTimeSamplingType_constructFromAcyclicFlag")
}

// Defined at TimeSamplingType.kl:19:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicTimeSamplingType_isUniform(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_isUniform")

  Abc::TimeSamplingType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>(this_, abcThis_)){
    setError("Error in AlembicTimeSamplingType_isUniform. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_.isUniform();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicTimeSamplingType_isUniform", false)
}

// Defined at TimeSamplingType.kl:20:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicTimeSamplingType_isCyclic(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_isCyclic")

  Abc::TimeSamplingType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>(this_, abcThis_)){
    setError("Error in AlembicTimeSamplingType_isCyclic. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_.isCyclic();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicTimeSamplingType_isCyclic", false)
}

// Defined at TimeSamplingType.kl:21:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicTimeSamplingType_isAcyclic(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_isAcyclic")

  Abc::TimeSamplingType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>(this_, abcThis_)){
    setError("Error in AlembicTimeSamplingType_isAcyclic. unable to convert: this_");
    return false;
  }
  bool abc_result = abcThis_.isAcyclic();
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicTimeSamplingType_isAcyclic", false)
}

// Defined at TimeSamplingType.kl:22:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicTimeSamplingType_getNumSamplesPerCycle(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_getNumSamplesPerCycle")

  Abc::TimeSamplingType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>(this_, abcThis_)){
    setError("Error in AlembicTimeSamplingType_getNumSamplesPerCycle. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_.getNumSamplesPerCycle();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicTimeSamplingType_getNumSamplesPerCycle", 0)
}

// Defined at TimeSamplingType.kl:23:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Float64 AlembicTimeSamplingType_getTimePerCycle(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicTimeSamplingType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicTimeSamplingType_getTimePerCycle")

  Abc::TimeSamplingType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>(this_, abcThis_)){
    setError("Error in AlembicTimeSamplingType_getTimePerCycle. unable to convert: this_");
    return 0;
  }
  double abc_result = abcThis_.getTimePerCycle();
  KL::Float64 _result;
  conv_to_baseType<KL::Float64, double>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicTimeSamplingType_getTimePerCycle", 0)
}
