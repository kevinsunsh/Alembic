////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
// USE COPY & PASTE TO MAKE USE OF THE FUNCTION IMPLEMENTATIONS!!
////////////////////////////////////////////////////////////////
// Generated by kl2exe version 1.11.2
////////////////////////////////////////////////////////////////

#include "AlembicDataType_functions.h"


#include "extension.h"
  

using namespace Fabric::EDK;


// Defined at DataType.kl:27:1
FABRIC_EXT_EXPORT void AlembicDataType_construct(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_construct")

  construct_AbcBase(Abc::DataType)
  
  ALEMBIC_CATCH_STATEMENT("AlembicDataType_construct")
}

// Defined at DataType.kl:28:1
FABRIC_EXT_EXPORT void AlembicDataType_free(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::IOParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_free")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    return;
  }
  free_AbcBase(Abc::DataType)
  
  ALEMBIC_CATCH_STATEMENT("AlembicDataType_free")
}

// Defined at DataType.kl:30:1
FABRIC_EXT_EXPORT void AlembicDataType_construct2Args(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam pod,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam extent
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_construct2Args")

  unsigned int abcPod = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(pod, abcPod)){
    setError("Error in AlembicDataType_construct2Args. unable to convert: pod");
    return;
  }
  unsigned int abcExtent = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(extent, abcExtent)){
    setError("Error in AlembicDataType_construct2Args. unable to convert: extent");
    return;
  }
  this_->handle = new Handle<Abc::DataType>(Abc::DataType((Abc::PlainOldDataType)abcPod, abcExtent));
  
  ALEMBIC_CATCH_STATEMENT("AlembicDataType_construct2Args")
}

// Defined at DataType.kl:35:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicDataType_getPod(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_getPod")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    setError("Error in AlembicDataType_getPod. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_.getPod();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicDataType_getPod", 0)
}

// Defined at DataType.kl:36:1
FABRIC_EXT_EXPORT void AlembicDataType_getPodName(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::String >::Result _result,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_getPodName")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    setError("Error in AlembicDataType_getPodName. unable to convert: this_");
    return;
  }

  std::string abc_result = PODName(abcThis_.getPod());
  conv_to_String(abc_result, _result);
    
  ALEMBIC_CATCH_STATEMENT("AlembicDataType_getPodName")
}

// Defined at DataType.kl:37:1
FABRIC_EXT_EXPORT void AlembicDataType_setPod(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam pod
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_setPod")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    setError("Error in AlembicDataType_setPod. unable to convert: this_");
    return;
  }
  unsigned int abcPod = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(pod, abcPod)){
    setError("Error in AlembicDataType_setPod. unable to convert: pod");
    return;
  }
  abcThis_.setPod((Abc::PlainOldDataType)abcPod);
  
  ALEMBIC_CATCH_STATEMENT("AlembicDataType_setPod")
}

// Defined at DataType.kl:38:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicDataType_getExtent(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_getExtent")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    setError("Error in AlembicDataType_getExtent. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_.getExtent();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicDataType_getExtent", 0)
}

// Defined at DataType.kl:39:1
FABRIC_EXT_EXPORT void AlembicDataType_setExtent(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::IOParam this_,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::UInt32 >::INParam extent
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_setExtent")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    setError("Error in AlembicDataType_setExtent. unable to convert: this_");
    return;
  }
  unsigned int abcExtent = 0;
  if(!conv_from_baseType<KL::UInt32, unsigned int>(extent, abcExtent)){
    setError("Error in AlembicDataType_setExtent. unable to convert: extent");
    return;
  }
  abcThis_.setExtent(abcExtent);

  ALEMBIC_CATCH_STATEMENT("AlembicDataType_setExtent")
}

// Defined at DataType.kl:40:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::UInt32 AlembicDataType_getNumBytes(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam this_
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_getNumBytes")

  Abc::DataType abcThis_;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(this_, abcThis_)){
    setError("Error in AlembicDataType_getNumBytes. unable to convert: this_");
    return 0;
  }
  unsigned int abc_result = abcThis_.getNumBytes();
  KL::UInt32 _result;
  conv_to_baseType<KL::UInt32, unsigned int>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicDataType_getNumBytes", 0)
}

// Defined at DataType.kl:42:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicDataType_operatorEquals(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam a,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam b
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_operatorEquals")

  Abc::DataType abcA;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(a, abcA)){
    setError("Error in AlembicDataType_operatorEquals. unable to convert: a");
    return false;
  }
  Abc::DataType abcB;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(b, abcB)){
    setError("Error in AlembicDataType_operatorEquals. unable to convert: b");
    return false;
  }
  bool abc_result = operatorEquals(abcA, abcB);
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicDataType_operatorEquals", false)
}

// Defined at DataType.kl:43:1
FABRIC_EXT_EXPORT Fabric::EDK::KL::Boolean AlembicDataType_operatorLess(
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam a,
  Fabric::EDK::KL::Traits< Fabric::EDK::KL::AlembicDataType >::INParam b
)
{
  ALEMBIC_TRY_STATEMENT("AlembicDataType_operatorLess")

  Abc::DataType abcA;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(a, abcA)){
    setError("Error in AlembicDataType_operatorLess. unable to convert: a");
    return false;
  }
  Abc::DataType abcB;
  if(!conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>(b, abcB)){
    setError("Error in AlembicDataType_operatorLess. unable to convert: b");
    return false;
  }
  bool abc_result = operatorLess(abcA, abcB);
  KL::Boolean _result;
  conv_to_baseType<KL::Boolean, bool>(abc_result, _result);
  return _result;

  ALEMBIC_CATCH_STATEMENT_RETURN("AlembicDataType_operatorLess", false)
}
